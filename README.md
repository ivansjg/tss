tss
---

Cli and transportation wrapper of [tss-lib](https://github.com/binance-chain/tss-lib)

[User guide](doc/UserGuide.md)

## How to Sign Ethereum transaction

1. Funding wallet with some ETH

First of all, we need to create a new Ethereum wallet. For that, we have to run keygen in all MPC nodes in order to
generate a key.

For this example, we are gonna use 3 MPC nodes/parties, with a threshold of 1.

Also, we will use Sepolia network for our tests. So you will
need an account in https://dashboard.alchemy.com/ , and then you will find your API_KEY there. 

Some useful links to interact with Sepolia network:
```
  # Sepolia RPC URL: https://eth-sepolia.g.alchemy.com/v2/<YOUR_API_KEY>
  # To get an API_KEY you need to sign up in alchemy.com . Then go to https://dashboard.alchemy.com/ and check your API_KEY
  # Sepolia Explorer: https://sepolia.etherscan.io/
  # Sepolia Faucet: https://sepoliafaucet.com/
  # Sepolia USDT Faucet: https://chaindrop.org/?chainid=11155111&token=0x6175a8471c2122f778445e7e07a164250a19e661
  # Sepolia USDT Contract Address: 0x6175a8471c2122f778445e7e07a164250a19e661
```

1.1 Build tss executable binary
```
cd tss
go build (or ~/go/go1.22.2/bin/go build)
```

1.2 Init all MPC parties
```
./tss init --home ./.test1 --vault_name "default" --moniker "test1" --password "123456789" --p2p.listen "/ip4/127.0.0.1/tcp/54964"
./tss init --home ./.test2 --vault_name "default" --moniker "test2" --password "123456789" --p2p.listen "/ip4/127.0.0.1/tcp/54965"
./tss init --home ./.test3 --vault_name "default" --moniker "test3" --password "123456789" --p2p.listen "/ip4/127.0.0.1/tcp/54966"
```

1.3 Create a secure channel so that parties can communicate each other
```
./tss channel --channel_expire 120
```
Output
```
channel id: 2366641E644
```

1.4 Start keygen in all parties
```
./tss keygen --home ./.test1 --vault_name "default" --parties 3 --threshold 1 --password "123456789" --channel_password "123456789" --channel_id "2366641E644"  --p2p.peer_addrs "/ip4/127.0.0.1/tcp/54964","/ip4/127.0.0.1/tcp/54965","/ip4/127.0.0.1/tcp/54966"
./tss keygen --home ./.test2 --vault_name "default" --parties 3 --threshold 1 --password "123456789" --channel_password "123456789" --channel_id "2366641E644"  --p2p.peer_addrs "/ip4/127.0.0.1/tcp/54964","/ip4/127.0.0.1/tcp/54965","/ip4/127.0.0.1/tcp/54966"
./tss keygen --home ./.test3 --vault_name "default" --parties 3 --threshold 1 --password "123456789" --channel_password "123456789" --channel_id "2366641E644"  --p2p.peer_addrs "/ip4/127.0.0.1/tcp/54964","/ip4/127.0.0.1/tcp/54965","/ip4/127.0.0.1/tcp/54966"
```
Output
```
...
public key compressed in hex: 036c402944a83f8aae63e0ae6effdfd9e6d14637d6b58d03bd9dbdb79526af9f79
address of this vault: 0x6Abc079738837FCa8F39FAb2b2189cc01A1bF3e0
...
```
Anyway, you can also describe a MPC party running following command:
```
> ./tss describe --home ./.test1 --vault_name default --password "123456789"
13:02:46.723  INFO        tss: public key compressed in hex: 036c402944a83f8aae63e0ae6effdfd9e6d14637d6b58d03bd9dbdb79526af9f79
 utils.go:121
address of this vault: 0x6Abc079738837FCa8F39FAb2b2189cc01A1bF3e0
config of this vault:
{
	"p2p": {
		"listen": "/ip4/127.0.0.1/tcp/54964",
...
```
So, at this point we already have a public key and its Ethereum address. Next step is to put money on it.

1.5 Fund our Ethereum wallet

As we are gonna use Sepolia network for out tests, you can find a Faucet in https://sepoliafaucet.com/ , and put some
money in 0x6Abc079738837FCa8F39FAb2b2189cc01A1bF3e0 .

2. Create unsigned Ethereum raw transaction

In this step, we are gonna send some money from our recently funded wallet (0x6Abc079738837FCa8F39FAb2b2189cc01A1bF3e0)
to another address controlled by us (to not lose funds).

For this, we will use the ethereum-tool available in https://github.com/ivansjg/ethereum-tool
```
createUnsignedRawEthereumTx PUBLIC_KEY_COMPRESSED DESTINATION_ETHEREUM_ADDRESS AMOUNT_IN_USD

ethereum-tool:> createUnsignedRawEthereumTx 036c402944a83f8aae63e0ae6effdfd9e6d14637d6b58d03bd9dbdb79526af9f79 0x395c6a329c0d46900C94039542a9EDbAF280D667 1
02f283aa36a780843b9aca008568e708ee3b82520894395c6a329c0d46900c94039542a9edbaf280d667870135ffd599076480c0
2024-05-13T17:34:40.593+02:00  INFO 55596 --- [           main] c.t.i.d.shell.SendOrderShellComponent    : Hash to sign: 1b50c133b0fd06168498b678578dae22cc80152dad718999059bc393e8a78120
2024-05-13T17:34:40.593+02:00  INFO 55596 --- [           main] c.t.i.d.shell.SendOrderShellComponent    : You can decode the transaction in https://rawtxdecode.in/
```
As you can see, we've built an unsigned Ethereum transaction which sends 1 USD, from the address generated by public key specified
(036c402944a83f8aae63e0ae6effdfd9e6d14637d6b58d03bd9dbdb79526af9f79) to 0x395c6a329c0d46900C94039542a9EDbAF280D667

Also the hash to sign that transaction has been shown up:
```
Hash to sign: 1b50c133b0fd06168498b678578dae22cc80152dad718999059bc393e8a78120
```
This is what we need to sign with MPC nodes.

3. Sign Ethereum transaction

First step here is to sign the obtained hash with the MPC nodes. We will need, 2 MPC nodes available when signing because
our threshold is 1 (remember threshold + 1 nodes are needed in order to sign in MPC protocol we are using).
```
./tss sign --home ./.test1 --vault_name "default" --password "123456789" --channel_password "123456789" --channel_id "863664234D4" --message "0x1b50c133b0fd06168498b678578dae22cc80152dad718999059bc393e8a78120"
./tss sign --home ./.test2 --vault_name "default" --password "123456789" --channel_password "123456789" --channel_id "863664234D4" --message "0x1b50c133b0fd06168498b678578dae22cc80152dad718999059bc393e8a78120"
```
Output
```
17:35:28.258  INFO        tss: [test1] received signature: 02460EA5934876797213DD88272CF7F688809F15A45B6AA159324A3A903B84E2406E79EA84A855D61DB81965258BD36A98CF7F62411735000E41D6AB17F33E2E keys.go:68
```
And that's it! This is the signature we have to add in our unsigned Ethereum transaction.

How can we add this signature to our unsigned Ethereum transaction? Using ethereum-tool again:
```
addSignToUnsignedRawEthereumTx PUBLIC_KEY_COMPRESSED UNSIGNED_ETHEREUM_RAW_TRANSACTION SIGNATURE HASH_TO_SIGN

ethereum-tool:> addSignToUnsignedRawEthereumTx 036c402944a83f8aae63e0ae6effdfd9e6d14637d6b58d03bd9dbdb79526af9f79 02f283aa36a780843b9aca008568e708ee3b82520894395c6a329c0d46900c94039542a9edbaf280d667870135ffd599076480c0 02460EA5934876797213DD88272CF7F688809F15A45B6AA159324A3A903B84E2406E79EA84A855D61DB81965258BD36A98CF7F62411735000E41D6AB17F33E2E 1b50c133b0fd06168498b678578dae22cc80152dad718999059bc393e8a78120
0x02f87583aa36a780843b9aca008568e708ee3b82520894395c6a329c0d46900c94039542a9edbaf280d667870135ffd599076480c001a002460ea5934876797213dd88272cf7f688809f15a45b6aa159324a3a903b84e2a0406e79ea84a855d61db81965258bd36a98cf7f62411735000e41d6ab17f33e2e
2024-05-13T17:36:28.548+02:00  INFO 55596 --- [           main] c.t.i.d.shell.SendOrderShellComponent    : You can decode the transaction in https://rawtxdecode.in/
```
There you go! Finally, we have our Ethereum transaction signed.

4. Broadcast signed Ethereum transaction

Last step is to publish our Ethereum signed transaction to Sepolia network, with the ethereum-tool:
```
ethereum-tool:> ethRpcSendRawTx 0x02f87583aa36a780843b9aca008568e708ee3b82520894395c6a329c0d46900c94039542a9edbaf280d667870135ffd599076480c001a002460ea5934876797213dd88272cf7f688809f15a45b6aa159324a3a903b84e2a0406e79ea84a855d61db81965258bd36a98cf7f62411735000e41d6ab17f33e2e
2024-05-13T17:38:47.821+02:00  INFO 55596 --- [           main] c.t.i.d.shell.EthereumRPCShellComponent  : Tx sent with hash: 0x21490273a77bdc5956aa7e30ef69e69a213d101d8bc0c2dfb2a13843338ebaa5
2024-05-13T17:38:47.821+02:00  INFO 55596 --- [           main] c.t.i.d.shell.EthereumRPCShellComponent  : Waiting for the receipt...
2024-05-13T17:38:51.241+02:00  INFO 55596 --- [           main] c.t.i.d.shell.EthereumRPCShellComponent  : Tx sent with hash: 0x21490273a77bdc5956aa7e30ef69e69a213d101d8bc0c2dfb2a13843338ebaa5
2024-05-13T17:38:51.241+02:00  INFO 55596 --- [           main] c.t.i.d.shell.EthereumRPCShellComponent  : Waiting for the receipt...
Tx sent with hash: 0x21490273a77bdc5956aa7e30ef69e69a213d101d8bc0c2dfb2a13843338ebaa5 - Fee cost in USD: 13.423452817
```
You can verify your transaction has been published in https://sepolia.etherscan.io/tx/0x21490273a77bdc5956aa7e30ef69e69a213d101d8bc0c2dfb2a13843338ebaa5

## Play in localhost

Please note, "--password" option should only be used in testing. 
Without this option, the cli would ask interactive input and confirm

0. build tss executable binary
```
git clone https://github.com/binance-chain/tss
cd tss
go build
```

1. init 3 parties
```
./tss init --home ~/.test1 --vault_name "default" --moniker "test1" --password "123456789"
./tss init --home ~/.test2 --vault_name "default" --moniker "test2" --password "123456789"
./tss init --home ~/.test3 --vault_name "default" --moniker "test3" --password "123456789"
```

2. generate channel id
replace value of "--channel_id" for following commands with generated one
```
./tss channel --channel_expire 30
```

3. keygen 
```
./tss keygen --home ~/.test1 --vault_name "default" --parties 3 --threshold 1 --password "123456789" --channel_password "123456789" --channel_id "802671B1B19"
./tss keygen --home ~/.test2 --vault_name "default" --parties 3 --threshold 1 --password "123456789" --channel_password "123456789" --channel_id "802671B1B19"
./tss keygen --home ~/.test3 --vault_name "default" --parties 3 --threshold 1 --password "123456789" --channel_password "123456789" --channel_id "802671B1B19"
```

4. sign
```
./tss sign --home ~/.test1 --vault_name "default" --password "123456789" --channel_password "123456789" --channel_id "802671B1B19"
./tss sign --home ~/.test2 --vault_name "default" --password "123456789" --channel_password "123456789" --channel_id "802671B1B19"
```

5. regroup - replace existing 3 parties with 3 brand new parties
```
# start 2 old parties (answer Y for isOld and IsNew interactive questions)
./tss regroup --home ~/.test1 --vault_name "default" --password "123456789" --new_parties 3 --new_threshold 1 --channel_password "123456789" --channel_id "802671B1B19"
./tss regroup --home ~/.test2 --vault_name "default" --password "123456789" --new_parties 3 --new_threshold 1 --channel_password "123456789" --channel_id "802671B1B19"
# start the new parties (answer n for isIold and Y for IsNew interactive questions)
./tss regroup --home ~/.test3 --vault_name "default" --password "123456789" --new_parties 3 --new_threshold 1 --channel_password "123456789" --channel_id "802671B1B19"
```

## TSS-1049 Upgrade

After TSS-1049 change, reshare now can work under environment with no SSDP support like a native AWS VPC:

```
Init:
A:
./tss init --vault_name rg55101 --moniker rg55101 --password 123456789 --p2p.listen "/ip4/127.0.0.1/tcp/55101"
B:
./tss init --vault_name rg55102 --moniker rg55102 --password 123456789 --p2p.listen "/ip4/127.0.0.1/tcp/55102"
C:
./tss init --vault_name rg55103 --moniker rg55103 --password 123456789 --p2p.listen "/ip4/127.0.0.1/tcp/55103"

Keygen by ABC (parties 3, threshold 1)
A:
./tss keygen --vault_name rg55101 --parties 3 --threshold 1 --password 123456789 --channel_password 123456789 --channel_id 20963C1108C --p2p.peer_addrs "/ip4/127.0.0.1/tcp/55102","/ip4/127.0.0.1/tcp/55103" --log_level debug 2>&1 | tee keygen_a.log
B:
./tss keygen --vault_name rg55102 --parties 3 --threshold 1 --password 123456789 --channel_password 123456789 --channel_id 20963C1108C --p2p.peer_addrs "/ip4/127.0.0.1/tcp/55101","/ip4/127.0.0.1/tcp/55103" --log_level debug 2>&1 | tee keygen_b.log
C:
./tss keygen --vault_name rg55103 --parties 3 --threshold 1 --password 123456789 --channel_password 123456789 --channel_id 20963C1108C --p2p.peer_addrs "/ip4/127.0.0.1/tcp/55101","/ip4/127.0.0.1/tcp/55102" --log_level debug 2>&1 | tee keygen_c.log
D:
N/A
Regroup
A
./tss regroup --is_old true --is_new_member true --vault_name rg55101 --password 123456789 --parties 3 --threshold 1 --new_parties 3 --new_threshold 1 --channel_password 123456789 --channel_id 20963C1108C --p2p.new_listen "/ip4/127.0.0.1/tcp/43899" --p2p.new_peer_addrs "/ip4/127.0.0.1/tcp/55101","/ip4/127.0.0.1/tcp/55102","/ip4/127.0.0.1/tcp/40855","/ip4/127.0.0.1/tcp/55104" 2>&1 | tee regroup_a.log
B
./tss regroup --is_old true --is_new_member true --vault_name rg55102 --password 123456789 --parties 3 --threshold 1 --new_parties 3 --new_threshold 1 --channel_password 123456789 --channel_id 20963C1108C --p2p.new_listen "/ip4/127.0.0.1/tcp/40855" --p2p.new_peer_addrs "/ip4/127.0.0.1/tcp/55101","/ip4/127.0.0.1/tcp/55102","/ip4/127.0.0.1/tcp/43899","/ip4/127.0.0.1/tcp/55104" 2>&1 | tee regroup_b.log
D
./tss init --vault_name rg55103 --moniker rg55104 --password 123456789 --p2p.listen "/ip4/127.0.0.1/tcp/55104"
./tss regroup --is_old false --is_new_member true --vault_name rg55103 --password 123456789 --parties 3 --threshold 1 --new_parties 3 --new_threshold 1 --channel_password 123456789 --channel_id 20963C1108C --p2p.new_peer_addrs "/ip4/127.0.0.1/tcp/55101","/ip4/127.0.0.1/tcp/55102","/ip4/127.0.0.1/tcp/43899","/ip4/127.0.0.1/tcp/40855" 2>&1 | tee regroup_d.log
```

## Note for running on macos catalina (To be enhanced)
```
xattr -d com.apple.quarantine ./tss
xattr -d com.apple.quarantine ./tbnbcli
xattr -d com.apple.quarantine ./bnbcli
```

## Network roles and connection topological
![](network/tss.png)

## Supported NAT Types

Referred to https://github.com/libp2p/go-libp2p/issues/375#issuecomment-407122416 We also have three nat-traversal solutions at the moment.

1. UPnP/NATPortMap 
<br><br> When NAT traversal is enabled (in go-libp2p, pass the NATPortMap() option to the libp2p constructor), libp2p will use UPnP and NATPortMap to ask the NAT's router to open and forward a port for libp2p. If your router supports either UPnP or NATPortMap, this is by far the best option.

2. STUN/hole-punching
<br><br> LibP2P has it's own version of the "STUN" protocol using peer-routing, external address discovery, and reuseport.

3. TURN-like protocol (relay)
<br><br> Finally, we have a TURN like protocol called p2p-circuit. This protocol allows libp2p nodes to "proxy" through other p2p nodes. All party clients registered to mainnet would automatically announce they support p2p-circuit (relay) for tss implementation.



### In WAN setting

| | Full cone | (Address)-restricted-cone | Port-restricted cone	| Symmetric NAT |
| ------ | ------ | ------ | ------ | ------ |
|Bootstrap (tracking) server| ✓ | ✘ | ✘ | ✘ |
|Relay server| ✓ | ✘ | ✘ | ✘ |
|Client| ✓ | ✓ | ✓ | ✓ (relay server needed) |

### In LAN setting

Nodes can connected to each other directly without setting bootstrap and relay server.  
We have 3 layers of bootstrapping session to help nodes connect with each other within a LAN
1. ssdp - started before 2 (raw tcp bootstrapping), node advertise their listen addr and moniker and record others. This is not encrypted.
2. raw tcp bootstrapping - node connect with each other via raw tcp to communicate their libp2pid, moniker, listen address. This is encrypted with channel id and channel password.
3. libp2p - node share signers/whether it is new party in regroup via formal libp2p
Note: keygen and regroup would relies on 1,2,3. But sign only relies on 3, which means the sign can achieved in WAN (with bootstrap server's help)